# 2장 의존성 역전하기

2장에서는 계층형 아키텍처의 대안에 대해서 이야기하고

단일 책임 원칙과 의존성 역전 원칙에 대해서 이야기한다.

# 단일 책임 원칙

- 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

- 일반적으로는 위와 같이 해석하지만 이는 단일 책임 원칙의 실제 의도가 아니다.

- 단일 책임 원칙의 실제 정의는 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

- 책임을 오로지 한 가지 일만 하는 것보다는 변경할 이유로 해석해야 한다.

- 컴포넌트를 변경할 이유가 오로지 한 가지라면 컴포넌트는 딱 한 가지 일만 하게 된다.

- 하지만 이보다 더 중요한 것은 변경할 이유가 오직 한 가지라는 것이다.

- 아키텍처에서의 의미는 만일 컴포넌트를 변경할 이유가 한 가지라면 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다는 의미이다. 소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작할 것이기 때문이다.

- 하지만 변경할 이유라는 것은 컴포넌트 간의 의존성을 통해 쉽게 전파된다.

![](https://velog.velcdn.com/images/ryool/post/2636aac5-b85d-438c-b5d8-e10493ec71b9/image.png)

- 어떤 컴포넌트의 의존성 각각은 이 컴포넌트를 변경하는 이유 하나씩에 해당한다.

- 컴포넌트 A는 다른 여러 컴포넌트에 의존하는(직접적, 전이된 것) 반면 E는 의존하는 것이 없다.

- 그렇기에 컴포넌트 E를 변경할 유일한 이유는 새로운 요구사항에 의해 E의 기능을 바꿔야 할 때뿐이다.

- 컴포넌트 A의 경우에는 모든 컴포넌트에 의존하고 있기에 다른 어떤 컴포넌트가 바뀌어도 같이 바뀌어야 한다.

# 의존성 역전 원칙

- 계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다.

- 단일 책임 원칙을 고수준에서 적용할 때 상위 계층들이 하위 계층들에 비해 변경할 이유가 더 많다는 것을 알 수 있다.

- 그렇기에 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.

- 이러한 문제는 의존성 역전 원칙을 통해서 해결할 수 있다.

- 의존성 역전 원칙은 다음과 같다.

- 코드 상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

- 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전 시킬 수 있다.

- 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 변경할 이유의 개수를 줄여보자.  
  ![](https://velog.velcdn.com/images/ryool/post/5df35a60-5c76-4914-8b68-611bf1798039/image.png)

- 먼저 이러한 구조를 가진다고 해보자.

- 도메인 계층에 영속성 계층의 엔티티와 리포지토리와 상호작용하는 서비스가 있다.

- 엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기에 엔티티를 도메인 계층으로 올린다.

- 하지만 이렇게 올리게 되면 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기에 두 계층 사이에 순환 의존성이 생긴다.

- 이 부분에 DIP를 적용한다.

- 도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 하는 것이다.
  ![](https://velog.velcdn.com/images/ryool/post/3fedd2a1-04dc-408e-8866-7802d8fad67f/image.png)

- 도메인 계층에 인터페이스를 도입해서 의존성을 역전 시킬 수 있고, 그 덕분에 영속성 계층이 도메인 계층에 의존하게 된다.

# 클린 아키텍처

- 클린 아키텍체에서는 설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다는 걸 의미

- 이것은 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다.

- 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.

![](https://velog.velcdn.com/images/ryool/post/c78f722e-3072-4536-b0d8-15b503cb4b3c/image.png)

- 출처 : http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

- 클린 아키텍처에서 모든 의존성은 도메인 로직을 향해 안쪽 방향으로 향한다.

- 아키텍처에서 가장 주요한 규칙은 의존성 규칙으로, 계층 간의 모든 의존성이 안쪽으로 향한다는 것이다.

- 아키텍처의 Core에는 주변의 Use Cases에서 접근하는 도메인 엔티티들이 있다.

- Use Cases는 서비스이다. 단일 책임을 갖기 위해 더 세분화되어 있다.

- Core 주변으로는 비즈니스 규칙을 지원하는 애플리케이션의 다른 모든 컴포넌트들을 확인할 수 있다.

- 여기서 지원은 영속성을 제공하거나 UI를 제공하는 것을 의미

- 바깥쪽 계층들은 다른 서드파티 컴포넌트에 어댑터를 제공할 수 있다.

- 클린 아키텍처에는 대가가 따른다.

- 도메인 계층이 영속성이나 UI 같은 외부 계층과 분리돼야 하기에 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지 보수해야 한다.

- 영속성 계층에서 ORM을 사용한다고 가정.

- ORM 프레임워크는 데이터베이스 구조 및 객체 필드와 데이터베이스 칼럼의 매핑을 서술한 메타데이터를 담고 있는 엔티티 클래스를 필요

- 도메인 계층은 영속성 계층을 모르기에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어야 한다.

- 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다는 의미.

- 하지만 이것은 도메인 코드를 프레임워크와의 결합을 제거된 상태로 만든다.

- JPA에서는 ORM이 관리하는 엔티티에 인자가 없는 기본 생성자를 추가하도록 강제하는데 이것이 바로 도메인 모델에는 포함해서는 안 될 프레임워크에 특화된 결합의 예.

# 육각형 아키텍처(헥사고날 아키텍처)

![](https://velog.velcdn.com/images/ryool/post/d80b75aa-bbee-483c-8511-4689125b3a40/image.png)

- 출처 : https://reflectoring.io/spring-hexagonal/

- 헥사고날 아키텍처는 애플리케이션 코어가 각 어댑터와 상호작용하기 위해 특정 포트를 제공하기에 포트와 어댑터 아키텍처라고도 불린다.

- 육각형 안에는 entity와 상호작용하는 use case가 있다.

- 육각형에서 외부로 향하는 의존성이 없기에 의존성 규칙이 그대로 적용되고 모든 의존성은 코어를 향한다.

- 육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터들이 있다.

- 왼쪽 어댑터는 애플리케이션 코어를 호출하기에 애플리케이션을 주도하는 어댑터, 오른쪽은 애플리케이션에 의해 호출되기에 애플리케이션에 의해 주도되는 어댑터이다.

- 애플리케이션 Core와 adapter들 간의 통신이 가능하려면 애플리케이션 Core가 각각의 Port를 제공해야 한다.

- 주도하는 어댑터(driving adapter)는 포트가 코어에 있는 유스케이스 클래스에 의해 구현되고 호출되는 인터페이스가 된다.(왼쪽)

- 주도되는 어댑터(driven adapter)에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.(오른쪽)

# 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 해 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다.

- 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링 될 수 있고, 영속성 코드와 UI 코드도 영속성 문제와 UI 문제에 맞게 자유롭게 모델링 될 수 있다.

---

출처 : 만들면서 배우는 클린 아키텍처 - 자바 코드로 구현하는 클린 웹 애플리케이션
