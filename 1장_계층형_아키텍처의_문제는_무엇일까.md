# 1장 계층형 아키텍처의 문제

# 계층형 아키텍처

![](https://velog.velcdn.com/images/ryool/post/e7ab8659-de05-4a27-a514-c7806bd18130/image.png)

- 웹 계층, 도메인 계층, 영속성 계층으로 구성된 전통적인 웹 애플리케이션 구조이다.
- 상위 수준 관점에서 일반적인 3계층 아키텍처를 표현한 것
- 웹 계층에서는 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다.
- 서비스에서는 필요한 비즈니스 로직을 수행
- 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해서 영속성 계층의 컴포넌트 호출

# 문제점 1 : 데이터베이스 주도 설계를 유도한다.

- 계층형 아키텍처의 토대는 데이터베이스이다.
- 웹 계층 -> 도메인 계층 -> 영속성 계층에 의존하기에 결국 데이터베이스에 의존하게 되기에 모든 것이 영속성 계층을 토대로 만들어진다.

- 상태가 아니라 행동을 중심으로 모델링 한다.?????
- 애플리케이션이든 상태가 중요한 요소이긴 하지만 행동이 상태를 바꾸는 주체이기에 행동이 비즈니스를 이끈다.

- 전통적인 아키텍처에서는 의존성의 방향에 따라서 데이터베이스의 구조를 먼저 생각하고 이를 토대로 도메인 로직을 구현한다.
- 하지만 비즈니스 관점에서는 전혀 맞지 않는다. -> 도메인 로직을 먼저 만들어야 한다.
- 도메인 로직을 먼저 만들어야 로직을 제대로 이해했는지 확인할 수 있고, 도메인 로직이 맞다는 걸 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.
- 데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크 때문이다.

![](https://velog.velcdn.com/images/ryool/post/9e4baeec-ca1f-4fe6-a84b-bb6ffb3b005c/image.png)

- ORM에 의해 관리되는 엔티티들은 보통 영속성 계층에 둔다.
- 계층은 아래쪽으로만 접근 가능하기에 도메인 계층에서는 엔티티에 접근할 수 있다.

- 하지만 이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.

- 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라, eager, lazy, 데이터베이스 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야 한다.

- 영속성 코드가 사실상 도메인 코드에 녹아들어 가기에 둘 중 하나만 바꾸는 것이 어려워진다.

# 문제점 2 : 지름길을 택하기 쉬워진다.

- 계층형 아키텍처에서는 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근이 가능하다는 것이다.

- 컴포넌트란 무엇인가?, 아래에 있는 계층?, 계층과 컴포넌트?

- 상위 계층에 위치한 컴포넌트에 접근해야 한다면 컴포넌트를 계층 아래로 내리면 된다.

![](https://velog.velcdn.com/images/ryool/post/24d08edc-7949-4fff-8d5d-1ffb72938989/image.png)

- 영속성 계층은 수년 동안 개발을 거쳐서 위와 같이 될 확률이 높다.

- 영속성 계층(최하단 계층)은 컴포넌트를 아래 계층으로 내릴수록 비대해진다.

- 어떤 계층에도 속하지 않는 거처럼 보이는 헬퍼 컴포넌트나 유틸리티 컴포넌트들이 아래 계층으로 내릴 가능성이 큰 후보이다.

# 문제점 3 : 테스트하기 어려워진다.

- 계층형 아키텍처를 사용할 때 계층을 건너뛰기도 한다.

- Entity의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층으로 접근하면 되기에 도메인 계층을 건드릴 필요가 없지 않을까라고 생각할 수 있다.

- 도메인 계층을 건너뛰는 것은 도메인 로직을 코드 여기저기에 흩어지게 만든다.
  ![](https://velog.velcdn.com/images/ryool/post/1ff1f2fb-2f2e-4fd2-937b-99a8fd3efa4c/image.png)

- 위와 같은 방식은 두 가지 문제점이 있다.

- 단 하나의 필드를 조작하는 것이라도 도메인 로직을 웹 계층에 구현하게 된다는 것이다.

- 만일 유스케이스가 확장되면 더 많은 도메인 로직을 웹 계층에 추가해서 애플리케이션 전반에 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높다.

- 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 mocking 해야 한다.

- 단위 테스트의 복잡도가 올라간다.

# 문제점 4 : 유스케이스를 숨긴다.

- 유스케이스란 정확히 무엇인가?

- 기능을 추가하거나 변경할 적절한 위치를 찾을 때 계층형 아키텍처는 우리의 발목을 잡는다.

- 계층형은 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.

- 이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워진 상태다

- 계층형 아키텍처는 도메인 서비스의 너비에 관한 규칙을 강제하지 않는다.

- 아래 그림처럼 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.
  ![](https://velog.velcdn.com/images/ryool/post/157000ee-4a4c-4ab2-8e8e-b2946a0b37c9/image.png)

- 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.

- 서비스를 테스트하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

# 문제점 5 : 동시 작업이 어려워진다.

- 계층형 아키텍처는 동시 작업 면에서 도움이 되지 않는다.

- 계층형 아키텍처에서는 모든 것이 영속성 계층 위에 만들어지기에 영속성 계층 -> 도메인 -> 웹 계층을 만들어야 한다. 그렇기에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.

- 데이터베이스 주도 설계를 하지 않는다면 인터페이스를 먼저 같이 정의하고, 각 개발자들이 실제 구현을 기다릴 필요 없이 이 인터페이스들로 작업하면 된다고 생각할 수 있다.

- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더 어렵다.

- 서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고, 이는 merge conflict와 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기하기 때문이다.

# 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수가 매우 쉬워지고 코드를 쉽게 변경하거나 추가할 수 있게 된다.

- 계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이 될 것이다.

---

출처 : 만들면서 배우는 클린 아키텍처 - 자바 코드로 구현하는 클린 웹 애플리케이션
